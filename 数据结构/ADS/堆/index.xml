<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>https://ArcticPirateL.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ADS/%E5%A0%86/</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://ArcticPirateL.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ADS/%E5%A0%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://ArcticPirateL.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ADS/%E5%A0%86/%E5%B7%A6%E5%BC%8F%E5%A0%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ArcticPirateL.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ADS/%E5%A0%86/%E5%B7%A6%E5%BC%8F%E5%A0%86/</guid>
      <description>左式堆#目标：#减少合并堆的时间复杂度到O(N)。
堆：结构特性（完全二叉树）+排列特性（最小堆）
其他堆存在的问题：若用数组存储，时间复杂度为θ(N)，不是上界；若用指针存储，找到下一条指针的过程所有操作时间都将增加。
概述#order property：与二叉堆相同，最小值在上。
structure property：不平衡二叉树。
定义#null path length：#Npl(X)，表示任何节点X到没有两个儿子的节点的最短路径长度。定义$Npl(NULL)=-1$。（叶子节点的Npl为0）
Npl计算：从底层向顶层扩展。公式如下：Npl(X) = min { Npl(C) + 1 for all C as children of X }
structure property#对于每个节点X，其左儿子的Npl大于等于右儿子的Npl。更倾向于向左延伸。
定理#若右路径包含r个节点，则左式堆至少包含$2^r$个节点。
若左式堆包含N个节点，则右路径最多包含$log(N+1)$个节点。
因此，若能够实现所有操作均在右路径上进行，则可以限制操作的时间复杂度。
困难情况：插入和合并。又因为插入属于合并的特殊情况，因此只需解决合并问题即可。
实现原理#节点数据结构#element、left pointer、right pointer、Npl
实例（递归求解）#首先比较根节点大小，较小的一方不变。即将H2与H1的右子堆合并。Merge(H1-&amp;gt;right, H2)
将得到的新堆赋值给原H1的右子堆。Attach(H2, H1-&amp;gt;right)
如果不符合左式堆条件，交换左右子堆。Swap(H1-&amp;gt;left, H1-&amp;gt;right)
代码实现#时间复杂度：$T_p=O(logN)$
实例（迭代求解）#选择根节点较小的堆，左子堆不变。 两个堆的右路径按大小排序，依次插入到上一步选择出的堆的右子堆上。（每个节点与其左子堆绑定）（此时并不符合左式堆） 对于右路径，从底层到顶层，检查Npl，如果不符合左式堆则调换左右子堆。 对于递归和迭代，所有操作时间复杂度均为log N。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ArcticPirateL.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ADS/%E5%A0%86/%E6%96%9C%E5%A0%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ArcticPirateL.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ADS/%E5%A0%86/%E6%96%9C%E5%A0%86/</guid>
      <description>斜堆#概述#左式堆和斜堆的关系类似于AVL树和Splay树的关系。斜堆是左式堆的简化版，不需要考虑Npl。
目标#连续M个操作总时间复杂度为$O(MlogN)$。
合并操作#总是交换左右子堆，不考虑Npl。
选择根节点较小的堆不变，将其左子堆换到右子堆的位置，再将原来的右子堆与另一个堆合并后attach到新堆的左子堆上。
当最后一步与空堆合并时，无需交换左右子堆。
注意最终得到的堆不一定是左式堆。
递归求解#迭代求解#分析#斜堆的优势#可以节省存放Npl所需的额外空间，且交换左右子堆时无需比较Npl大小。
准确的右路径长度仍然未知。
摊还分析#插入和删除操作均属于合并操作。只要证明合并的均摊时间复杂度为$O(logN)$即可。
势能函数定义：
右子堆节点个数？No，由于最初为空堆，势能为0，后面任何操作势能都会大于0，缺少势能减少的方向（bad luck）的情况。 正确答案：heavy nodes的个数。 heavy nodes定义
对于一个节点，若其右侧的节点总数不小于总节点数的一半（即大于左侧节点总数），则称这个节点为heavy node，代表bad luck的情况；若反之，左侧节点总数大于右侧，则称为light node，代表good luck的情况。
注意：这里的总节点数包括了根节点本身，因此左右子堆节点数相同的点不属于heavy node或light node。
规律： heavy或light性质前后发生改变的节点一定在最初的右路径上。
​ 且在右路径上原heavy的节点经过merge后一定会变成light节点。
​ 且在右路径上原light的节点经过merge后不一定会变成heavy节点。</description>
    </item>
    
    <item>
      <title>二项队列</title>
      <link>https://ArcticPirateL.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ADS/%E5%A0%86/%E4%BA%8C%E9%A1%B9%E9%98%9F%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ArcticPirateL.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ADS/%E5%A0%86/%E4%BA%8C%E9%A1%B9%E9%98%9F%E5%88%97/</guid>
      <description>二项队列#定义#不是单个的堆结构的树，而是堆结构树的集合，成为森林。其中的每棵堆结构树都是一个二项树。
height为0的二项树只有一个节点。
height为k的二项树成为$B_k$，由一个$B_{k-1}$树连接到另一个$B_{k-1}$树的根节点上得到。
规律：$B_k$树有k个儿子，包含$2^k$个节点，深度为d处的节点数为$C^k_d$。
结论：任意大小的优先队列都能用唯一的二项树集合表示。
操作#FindMin#找到最小值，遍历查找所有根中的最小值即可，最多共有$logN$个根节点，时间复杂度为$O(logN)$。
可以选择记录最小值所在的根，若更改则更新，此时时间复杂度为$O(1)$。
然而若常见操作为delete min而不是find min，将会频繁的更新，用途不显著。
Merge#类似于二进制加法。合并时可能由多种选择，不同选择结果不同，无硬性规定。
合并时需确保新的根节点为较小的根。
时间复杂度取决于树的数量，为$O(logN)$。
必须将合并后的树进行按高度排序，而非按key值排序。
Insertion#插入属于特殊的合并操作，时间复杂度同样为$O(logN)$。
若最小的不存在的树是$B_i$，则时间复杂度为$T_p=Const*(i+1)$。
向初始为空的二项队列中插入N次，会发生最坏情况为$O(N)$，因此平均时间为常数时间。
DeleteMin#FindMin in $B_k$。$O(logN)$ 在二项队列中移除$B_k$。$O(1)$ 移除$B_k$的根节点。$O(logN)$ 合并两个二项队列。$O(logN)$ 因此，总时间复杂度为$O(logN)$。</description>
    </item>
    
  </channel>
</rss>
